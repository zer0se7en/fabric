// Code generated by protoc-gen-go. DO NOT EDIT.
// source: gateway/gateway.proto

package gateway

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	common "github.com/hyperledger/fabric-protos-go/common"
	peer "github.com/hyperledger/fabric-protos-go/peer"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Result is the value that is returned by the transaction function.
type Result struct {
	// The byte array returned from the chaincode invocation.
	Value                []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_285396c8df15061f, []int{0}
}

func (m *Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Result.Unmarshal(m, b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Result.Marshal(b, m, deterministic)
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return xxx_messageInfo_Result.Size(m)
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// ProposedTransaction contains the signed proposal ready for endorsement plus any processing options.
type ProposedTransaction struct {
	// The signed proposal.
	Proposal *peer.SignedProposal `protobuf:"bytes,1,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// Other options will be added here.  The following are experimental at the moment.
	TxId                 string   `protobuf:"bytes,2,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	ChannelId            string   `protobuf:"bytes,3,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProposedTransaction) Reset()         { *m = ProposedTransaction{} }
func (m *ProposedTransaction) String() string { return proto.CompactTextString(m) }
func (*ProposedTransaction) ProtoMessage()    {}
func (*ProposedTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_285396c8df15061f, []int{1}
}

func (m *ProposedTransaction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProposedTransaction.Unmarshal(m, b)
}
func (m *ProposedTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProposedTransaction.Marshal(b, m, deterministic)
}
func (m *ProposedTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposedTransaction.Merge(m, src)
}
func (m *ProposedTransaction) XXX_Size() int {
	return xxx_messageInfo_ProposedTransaction.Size(m)
}
func (m *ProposedTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposedTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_ProposedTransaction proto.InternalMessageInfo

func (m *ProposedTransaction) GetProposal() *peer.SignedProposal {
	if m != nil {
		return m.Proposal
	}
	return nil
}

func (m *ProposedTransaction) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *ProposedTransaction) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

// PreparedTransaction contains the set of transaction responses from the endorsing peers for signing by the client
// before submitting to ordering service (via gateway).
type PreparedTransaction struct {
	// The transaction envelope.
	Envelope *common.Envelope `protobuf:"bytes,1,opt,name=envelope,proto3" json:"envelope,omitempty"`
	// The value that is returned by the transaction function during endorsement.
	Response *Result `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`
	// The following fields are pulled out of the envelope to the top level for convenience to the client.
	TxId                 string   `protobuf:"bytes,3,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	ChannelId            string   `protobuf:"bytes,4,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreparedTransaction) Reset()         { *m = PreparedTransaction{} }
func (m *PreparedTransaction) String() string { return proto.CompactTextString(m) }
func (*PreparedTransaction) ProtoMessage()    {}
func (*PreparedTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_285396c8df15061f, []int{2}
}

func (m *PreparedTransaction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PreparedTransaction.Unmarshal(m, b)
}
func (m *PreparedTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PreparedTransaction.Marshal(b, m, deterministic)
}
func (m *PreparedTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreparedTransaction.Merge(m, src)
}
func (m *PreparedTransaction) XXX_Size() int {
	return xxx_messageInfo_PreparedTransaction.Size(m)
}
func (m *PreparedTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_PreparedTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_PreparedTransaction proto.InternalMessageInfo

func (m *PreparedTransaction) GetEnvelope() *common.Envelope {
	if m != nil {
		return m.Envelope
	}
	return nil
}

func (m *PreparedTransaction) GetResponse() *Result {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *PreparedTransaction) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *PreparedTransaction) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

// Event contains the data returned in the stream from the Submit service.
// This is currently experimental and highly likely to change during gateway development.
type Event struct {
	Value                []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_285396c8df15061f, []int{3}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*Result)(nil), "protos.Result")
	proto.RegisterType((*ProposedTransaction)(nil), "protos.ProposedTransaction")
	proto.RegisterType((*PreparedTransaction)(nil), "protos.PreparedTransaction")
	proto.RegisterType((*Event)(nil), "protos.Event")
}

func init() { proto.RegisterFile("gateway/gateway.proto", fileDescriptor_285396c8df15061f) }

var fileDescriptor_285396c8df15061f = []byte{
	// 386 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x52, 0x51, 0x8b, 0xd3, 0x40,
	0x10, 0x26, 0xde, 0xb5, 0x97, 0x9b, 0x3b, 0x45, 0x36, 0x2a, 0x47, 0xa4, 0x52, 0x0a, 0x42, 0x11,
	0x9b, 0x48, 0x04, 0x7d, 0xaf, 0x04, 0xe9, 0x5b, 0x48, 0x7d, 0xf2, 0x45, 0x36, 0xc9, 0x98, 0x04,
	0xd2, 0xdd, 0x65, 0x77, 0x53, 0xdb, 0x07, 0x7f, 0x8d, 0x3f, 0xc4, 0xbf, 0x26, 0xc9, 0x6e, 0x6a,
	0xad, 0xd6, 0x7b, 0x1a, 0x76, 0xbe, 0x6f, 0xe6, 0xfb, 0x66, 0x76, 0xe0, 0x69, 0x49, 0x35, 0x7e,
	0xa3, 0xfb, 0xd0, 0xc6, 0x40, 0x48, 0xae, 0x39, 0x19, 0xf7, 0x41, 0xf9, 0x9e, 0x40, 0x94, 0xa1,
	0x90, 0x5c, 0x70, 0x45, 0x1b, 0x03, 0xfa, 0x5e, 0xce, 0x37, 0x1b, 0xce, 0x42, 0x13, 0x4c, 0x72,
	0xf6, 0x02, 0xc6, 0x29, 0xaa, 0xb6, 0xd1, 0xe4, 0x09, 0x8c, 0xb6, 0xb4, 0x69, 0xf1, 0xce, 0x99,
	0x3a, 0xf3, 0xdb, 0xd4, 0x3c, 0x66, 0xdf, 0xc1, 0x4b, 0xfa, 0x36, 0x58, 0x7c, 0x92, 0x94, 0x29,
	0x9a, 0xeb, 0x9a, 0x33, 0x12, 0x81, 0x3b, 0x74, 0xef, 0xf9, 0x37, 0xd1, 0x33, 0xd3, 0x50, 0x05,
	0xeb, 0xba, 0x64, 0x58, 0x24, 0x16, 0x4d, 0x0f, 0x3c, 0xe2, 0xc1, 0x48, 0xef, 0xbe, 0xd4, 0xc5,
	0xdd, 0x83, 0xa9, 0x33, 0xbf, 0x4e, 0x2f, 0xf5, 0x6e, 0x55, 0x90, 0x09, 0x40, 0x5e, 0x51, 0xc6,
	0xb0, 0xe9, 0x90, 0x8b, 0x1e, 0xb9, 0xb6, 0x99, 0x55, 0x31, 0xfb, 0xe1, 0x74, 0xfa, 0x28, 0xa8,
	0xfc, 0x53, 0xff, 0x35, 0xb8, 0xc8, 0xb6, 0xd8, 0x70, 0x81, 0x56, 0xff, 0x71, 0x60, 0xe7, 0x8a,
	0x6d, 0x3e, 0x3d, 0x30, 0xc8, 0x2b, 0x70, 0x25, 0x2a, 0xc1, 0x99, 0xc2, 0x5e, 0xfc, 0x26, 0x7a,
	0x34, 0xb8, 0x35, 0xc3, 0xa7, 0x07, 0xfc, 0xb7, 0xcb, 0x8b, 0xb3, 0x2e, 0x2f, 0x4f, 0x5d, 0x4e,
	0x60, 0x14, 0x6f, 0x91, 0x9d, 0xd9, 0x61, 0xf4, 0xd3, 0x81, 0xab, 0x8f, 0xe6, 0x9f, 0xc8, 0x07,
	0xb8, 0x8a, 0x59, 0xc1, 0xa5, 0x42, 0xf2, 0x7c, 0xf0, 0xf0, 0x8f, 0x05, 0xfb, 0x47, 0xe0, 0xdf,
	0xd3, 0xbf, 0x83, 0xf1, 0xba, 0xcd, 0x36, 0xb5, 0x26, 0xff, 0xa3, 0xf9, 0x0f, 0x07, 0xb0, 0x37,
	0xf7, 0xc6, 0x21, 0xef, 0xc1, 0x8d, 0x3b, 0x4b, 0x54, 0xdf, 0xa3, 0x7e, 0xb2, 0x9e, 0x65, 0x05,
	0x2f, 0xb9, 0x2c, 0x83, 0x6a, 0x2f, 0x50, 0x36, 0x58, 0x94, 0x28, 0x83, 0xaf, 0x34, 0x93, 0x75,
	0x3e, 0xf0, 0xec, 0x19, 0x2e, 0x6f, 0xed, 0x9c, 0x49, 0x97, 0x4e, 0x9c, 0xcf, 0x61, 0x59, 0xeb,
	0xaa, 0xcd, 0xba, 0xbf, 0x09, 0x8f, 0xaa, 0x43, 0x53, 0xbd, 0x30, 0xd5, 0x8b, 0x92, 0x0f, 0x77,
	0x9c, 0x99, 0x0b, 0x7e, 0xfb, 0x2b, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x5f, 0x1b, 0x67, 0xe1, 0x02,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GatewayClient interface {
	// The Endorse service passes the ProposedTransaction (which contains the signed proposal)
	// to the gateway in order to obtain sufficient endorsement.
	// The gateway will determine the endorsement plan for the requested chaincode and
	// forward to the appropriate peers for endorsement. It will return to the client a
	// PreparedTransaction message which contains a Envelope message as defined
	// in fabric-protos/common/common.proto.  The client must sign the contents of this
	// envelope before invoking the Submit service
	Endorse(ctx context.Context, in *ProposedTransaction, opts ...grpc.CallOption) (*PreparedTransaction, error)
	// Ths Submit service will process the PreparedTransaction message returned from Endorse service
	// once it has been signed by the client. A stream is opened to return multiple return values.
	// - The Gateway will register transaction event listeners for the given channel/txId.
	// - It will then broadcast the Envelope to the ordering service.
	// - The success/error response is passed back to the client in the stream
	// - The Gateway awaits sufficient transaction commit events before returning and closing the stream,
	//   indicating to the client that transaction has been committed.
	Submit(ctx context.Context, in *PreparedTransaction, opts ...grpc.CallOption) (Gateway_SubmitClient, error)
	// The Evaluate service passes the ProposedTransaction (which contains the signed proposal)
	// to the gateway in order to invoke the transaction function and return the result to the client.
	// No ledger updates are make.  The gateway will select an appropriate peer to query based on
	// block height and load.
	Evaluate(ctx context.Context, in *ProposedTransaction, opts ...grpc.CallOption) (*Result, error)
}

type gatewayClient struct {
	cc *grpc.ClientConn
}

func NewGatewayClient(cc *grpc.ClientConn) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) Endorse(ctx context.Context, in *ProposedTransaction, opts ...grpc.CallOption) (*PreparedTransaction, error) {
	out := new(PreparedTransaction)
	err := c.cc.Invoke(ctx, "/protos.Gateway/Endorse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Submit(ctx context.Context, in *PreparedTransaction, opts ...grpc.CallOption) (Gateway_SubmitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Gateway_serviceDesc.Streams[0], "/protos.Gateway/Submit", opts...)
	if err != nil {
		return nil, err
	}
	x := &gatewaySubmitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gateway_SubmitClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type gatewaySubmitClient struct {
	grpc.ClientStream
}

func (x *gatewaySubmitClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gatewayClient) Evaluate(ctx context.Context, in *ProposedTransaction, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/protos.Gateway/Evaluate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
type GatewayServer interface {
	// The Endorse service passes the ProposedTransaction (which contains the signed proposal)
	// to the gateway in order to obtain sufficient endorsement.
	// The gateway will determine the endorsement plan for the requested chaincode and
	// forward to the appropriate peers for endorsement. It will return to the client a
	// PreparedTransaction message which contains a Envelope message as defined
	// in fabric-protos/common/common.proto.  The client must sign the contents of this
	// envelope before invoking the Submit service
	Endorse(context.Context, *ProposedTransaction) (*PreparedTransaction, error)
	// Ths Submit service will process the PreparedTransaction message returned from Endorse service
	// once it has been signed by the client. A stream is opened to return multiple return values.
	// - The Gateway will register transaction event listeners for the given channel/txId.
	// - It will then broadcast the Envelope to the ordering service.
	// - The success/error response is passed back to the client in the stream
	// - The Gateway awaits sufficient transaction commit events before returning and closing the stream,
	//   indicating to the client that transaction has been committed.
	Submit(*PreparedTransaction, Gateway_SubmitServer) error
	// The Evaluate service passes the ProposedTransaction (which contains the signed proposal)
	// to the gateway in order to invoke the transaction function and return the result to the client.
	// No ledger updates are make.  The gateway will select an appropriate peer to query based on
	// block height and load.
	Evaluate(context.Context, *ProposedTransaction) (*Result, error)
}

// UnimplementedGatewayServer can be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (*UnimplementedGatewayServer) Endorse(ctx context.Context, req *ProposedTransaction) (*PreparedTransaction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Endorse not implemented")
}
func (*UnimplementedGatewayServer) Submit(req *PreparedTransaction, srv Gateway_SubmitServer) error {
	return status.Errorf(codes.Unimplemented, "method Submit not implemented")
}
func (*UnimplementedGatewayServer) Evaluate(ctx context.Context, req *ProposedTransaction) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Evaluate not implemented")
}

func RegisterGatewayServer(s *grpc.Server, srv GatewayServer) {
	s.RegisterService(&_Gateway_serviceDesc, srv)
}

func _Gateway_Endorse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposedTransaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Endorse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Gateway/Endorse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Endorse(ctx, req.(*ProposedTransaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Submit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PreparedTransaction)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServer).Submit(m, &gatewaySubmitServer{stream})
}

type Gateway_SubmitServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type gatewaySubmitServer struct {
	grpc.ServerStream
}

func (x *gatewaySubmitServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _Gateway_Evaluate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposedTransaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Evaluate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Gateway/Evaluate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Evaluate(ctx, req.(*ProposedTransaction))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Endorse",
			Handler:    _Gateway_Endorse_Handler,
		},
		{
			MethodName: "Evaluate",
			Handler:    _Gateway_Evaluate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Submit",
			Handler:       _Gateway_Submit_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gateway/gateway.proto",
}
